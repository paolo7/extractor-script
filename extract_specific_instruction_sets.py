# This script extracts specific sets of instructions generated by the prohow-crawler
# The urls to extract are found in the extract_specific_sets_instructions.txt file
# The extract_specific_sets_instructions.txt file should contain one URL per line
# only the sets of instructions corresponding to these URLs will be extracted
# the URLs will be matched in a non-case sensitive way

## IN-CODE PARAMETERS

# This parameter can be changed to only select instructions with specific language tags.
# More specifically, the algorighm will only consider files having a name which starts with at least one 
# DEFAULT:
# list_of_allowed_languages = []
list_of_allowed_languages = []
# for example, for English and Spanish: 
# list_of_allowed_languages = ["en","es"]

# This parameter can be changed to only select instructions witin specific categories.
# More specifically, the algorighm will select all the instructions which directly belong to one of the types
# in list_of_allowed_categories, or one their sub-classes as defined in RDFS, in the Turtle file class_hierarchy.ttl
# DEFAULT:
# list_of_allowed_categories = []
list_of_allowed_categories = []
# for example, the following configuration extracts only breakfast food instructions in Spanish and English
# list_of_allowed_categories = ["http://www.wikihow.com/Category:Breakfast","http://es.wikihow.com/Categor%C3%ADa:Desayunos"]

# ADVANCED PARAMETERS

# This parameter allows advanced filtering of the sets of instructions to output
# If this parameter is set to false, all the following parameters are considered set to false too
# DEFAULT:
# perform_sparql_filtering = False
perform_sparql_filtering = False
# If this parameter is set to true, sets of instructions containing multiple methods will be ignored
# DEFAULT:
# remove_multiple_methods = False
remove_multiple_methods = False
# If this parameter is set to true, sets of instructions containing multiple sets of requirements will be ignored
# DEFAULT:
# remove_multiple_requirements = False
remove_multiple_requirements = False

# These parameters allow you to select instructions with a number of steps and requirements within a certain range
# If this parameter larger than -1, sets of instructions with less than this number of steps will be ignored
# DEFAULT:
# min_number_of_steps = -1
min_number_of_steps = -1
# If this parameter larger than -1, sets of instructions with more than this number of steps will be ignored
# DEFAULT:
# max_number_of_steps = -1
max_number_of_steps = -1
# If this parameter larger than -1, sets of instructions with less than this number of requirements will be ignored
# DEFAULT:
# min_number_of_requirements = -1
min_number_of_requirements = -1
# If this parameter larger than -1, sets of instructions with more than this number of requirements will be ignored
# DEFAULT:
# max_number_of_requirements = -1
max_number_of_requirements = -1

# If this list contains at least one element, at least one pair of strings inside must occur in the subject and object
# of an owl:sameAs relation. For example, by setting:
# owl_sameAs_required_prefixes = [["http://es.wikihow.com/","http://www.wikihow.com/"]]
# we select only instructions in English which have an equivalent Spanish page or vice-versa
# DEFAULT:
# owl_sameAs_required_prefixes = []
owl_sameAs_required_prefixes = []

# Turn true if you want a simplified output, with only one list of steps and one list of requirements per instructions set
# DEFAULT:
# save_simplified = False
save_simplified = False

# Turn true if you want the label and the abstract of entities to be unified in a single literal
# DEFAULT:
# concatenate_label_abstract = False
concatenate_label_abstract = False

# If the labels of some entities contain HTML, but you are interested only in their textual content, then turn this
# variable to true and the HTML code will be stripped from the labels.
# DEFAULT:
# parse_html_into_text = False
parse_html_into_text = False

# Set this value to true if you want the simplified representation to contain information on whether a requirement is
# to be considered a tool (prohow:requirement) or as a consumable ingredient (prohow:requirement)
# DEFAULT:
# get_requirement_types = False
get_requirement_types = False


# CODE START

import os, io, ntpath, string, rdflib, codecs
from rdflib import RDF, RDFS, URIRef, Literal, XSD


if parse_html_into_text:
  from bs4 import BeautifulSoup

hierarchy = {}
# load hieararchy if present
if os.path.isfile("class_hierarchy.ttl"):
    print "Loading a class hierarchy"
    num = 0
    h = open("class_hierarchy.ttl",'r')
    for line in h:
        urls = line.split("> rdfs:subClassOf <")
        #print urls
        url1 = urls[0][1:]
        url2 = urls[1][:-4]
        #print url1
        #print url2
        hierarchy[url1] = url2
        num += 1
    h.close()
    print str(num)+" sub-class relations extracted."

def is_subclass_of(concept,super):
    return is_subclass_of_with_recursion_limit(concept,super,0)

def is_subclass_of_with_recursion_limit(concept,super,level):
    if level > 30:
        return False
    if concept == super:
        return True
    if concept in hierarchy:
        return is_subclass_of_with_recursion_limit(hierarchy[concept],super,level+1)
    return False

list_of_urls = []
if os.path.isfile("extract_specific_sets_instructions.txt"):
    print "Loading the extract_specific_sets_instructions file"
    conf = open("extract_specific_sets_instructions.txt",'r')
    for line in conf:
        extracted = line.lower().strip()
        if len(extracted) > 0:
            list_of_urls.append(extracted);
    conf.close()

print "Specific URL extraction configured with: "+str(len(list_of_urls))+" URLs"
	


out = open('extracted_graph.ttl','w')

prefixes = u"@prefix w: <http://w3id.org/prohowlinks#> .\n@prefix oa: <http://www.w3.org/ns/oa#> .\n@prefix prohow: <http://w3id.org/prohow#> .\n\
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n\
@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix dbo: <http://dbpedia.org/ontology/> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n"

sparql_prefixes = "PREFIX prohow: <http://w3id.org/prohow#> \n PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> \n\
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#> \n PREFIX oa: <http://www.w3.org/ns/oa#> \n\
PREFIX owl: <http://www.w3.org/2002/07/owl#> "

out_simple = None
gor = None
if save_simplified:
    gor = rdflib.Graph()
    out_simple = open('extracted_simplified_graph.ttl','w')

out.write(prefixes)

def clean(text):
    if text is None:
        return ""
    if not parse_html_into_text:
        return text
    else:
        soup = BeautifulSoup(text, "html.parser")
        for div in soup.find_all("div", {'class': 'img-whvid'}):
            div.decompose()
        for div in soup.find_all("div", {'class': 'whvid_cont'}):
            div.decompose()
        for div in soup.find_all("div", {'class': 'whvid_cont_hideable'}):
            div.decompose()
        for div in soup.find_all("div", {'class': 'whvid_both'}):
            div.decompose()
        for div in soup.find_all("div", {'class': 'whvid_gif'}):
            div.decompose()
        for div in soup.find_all("script"):
            div.decompose()
        return " ".join(soup.text.strip().split())

def encodeLabel(label,lang):
    return "\"\"\""+clean(label)+"\"\"\"@"+lang

def save(line, lang):
    if perform_sparql_filtering:
        g = rdflib.Graph()
        go = rdflib.Graph()
        result = g.parse(data = prefixes+u"\n"+(line.decode('utf8')), format="turtle")
        if remove_multiple_methods:
            qres = g.query(
                sparql_prefixes+"""SELECT DISTINCT ?m
                   WHERE {
                      ?main rdf:type prohow:instruction_set .
                      ?main prohow:has_method ?m .
                   }""")
            if len(qres) > 1:
                return False
        if min_number_of_steps > -1 or max_number_of_steps > -1:
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?p
                               WHERE {
                                  {?main rdf:type prohow:instruction_set .
                                  ?main prohow:has_method ?m .
                                  ?m prohow:has_step ?p .}
                                  UNION
                                  {?main rdf:type prohow:instruction_set .
                                  ?main prohow:has_method ?m .
                                  ?m prohow:has_step ?part .
                                  ?part prohow:has_method ?pm .
                                  ?pm prohow:has_step ?p .}
                               }""")
            if min_number_of_steps > -1 and len(qres) < min_number_of_steps:
                return False
            if max_number_of_steps > -1 and len(qres) > max_number_of_steps:
                return False
        if remove_multiple_requirements:
            qres = g.query(
                sparql_prefixes+"""SELECT DISTINCT ?r
                   WHERE {
                      ?main rdf:type prohow:instruction_set .
                      ?main prohow:requires ?r .
                      ?r prohow:has_step ?s .
                      ?s rdf:type prohow:consumable .
                   }""")
            if len(qres) > 2:
                return False
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?r
                              WHERE {
                                 ?main rdf:type prohow:instruction_set .
                                 ?main prohow:requires ?r .
                                 ?r prohow:has_step ?s .
                                 ?s rdf:type prohow:requirement .
                              }""")
            if len(qres) > 2:
                return False
        if min_number_of_requirements > -1 or max_number_of_requirements > -1:
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?s
                   WHERE {
                      ?main rdf:type prohow:instruction_set .
                      ?main prohow:requires ?r .
                      ?r prohow:has_step ?s .
                   }""")
            if min_number_of_requirements > -1 and len(qres) < min_number_of_requirements:
                return False
            if max_number_of_requirements > -1 and len(qres) > max_number_of_requirements:
                return False
        if len(owl_sameAs_required_prefixes) > 0:
            found = False
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?s ?o
                       WHERE {
                          ?s owl:sameAs ?o .
                       }""")
            for row in qres:
                if not found:
                    for pair in owl_sameAs_required_prefixes:
                        if (pair[0] in row["s"] and pair[1] in row["o"]) or (pair[1] in row["s"] and pair[0] in row["o"]):
                            found = True
            if not found:
                return False
        # Save files in a simplified format for easier computation
        if save_simplified:
            # get title
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?main ?l
                               WHERE {
                                  ?main rdf:type prohow:instruction_set .
                                  ?main rdfs:label ?l .
                               }""")
            if len(qres) < 1:
                return False
            title_l = qres.bindings[0]["l"]
            main_uri = qres.bindings[0]["main"]
            go.add((URIRef(main_uri), RDF.type, URIRef(u"http://w3id.org/prohow#instruction_set")))
            go.add((URIRef(main_uri), RDFS.label,
                    Literal(clean(title_l), lang = lang)))
            go.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#language"),
                  URIRef(u"http://w3id.org/prohow#language_code_"+(lang.decode('utf8')))))
            gor.add((URIRef(main_uri), RDF.type, URIRef(u"http://w3id.org/prohow#instruction_set")))
            gor.add((URIRef(main_uri), RDFS.label,
                    Literal(clean(title_l), lang=lang)))
            gor.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#language"),
                    URIRef(u"http://w3id.org/prohow#language_code_" + (lang.decode('utf8')))))
            # get requirements
            if get_requirement_types:
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?l ?type
                                   WHERE {
                                      <""" + str(main_uri) + """> prohow:requires ?r .
                                      ?r prohow:has_step ?s .
                                      ?s rdfs:label ?l .
                                      ?s rdf:type ?type .
                                   }""")
            else:
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?l
                                   WHERE {
                                      <""" + str(main_uri) + """> prohow:requires ?r .
                                      ?r prohow:has_step ?s .
                                      ?s rdfs:label ?l .
                                   }""")
            for row in qres:
                r_label = row["l"]
                r_uri = row["s"]
                if get_requirement_types:
                    type = row["type"]
                    go.add((URIRef(r_uri), RDF.type, URIRef(type)))
                    gor.add((URIRef(r_uri), RDF.type, URIRef(type)))
                go.add((URIRef(main_uri),URIRef(u"http://w3id.org/prohow#requires"),URIRef(r_uri)))
                go.add((URIRef(r_uri), RDFS.label, Literal(clean(r_label), lang = lang)))               
                gor.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#requires"), URIRef(r_uri)))
                gor.add((URIRef(r_uri), RDFS.label, Literal(clean(r_label), lang=lang)))               
            # get ordered steps
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?m2
                               WHERE {
                                  <""" + str(main_uri) + """> prohow:has_method ?m .
                                  ?m prohow:has_step ?s .
                                  ?s prohow:has_method ?m2 .
                               }""")
            if len(qres) > 1:
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?l ?a
                                       WHERE {
                                          <""" + str(main_uri) + """> prohow:has_method ?m .
                                          ?m prohow:has_step ?part .
                                          ?part prohow:has_method ?m1 .
                                          ?m1 prohow:has_step ?s .
                                          ?s rdfs:label ?l
                                          OPTIONAL {
                                            ?s dbo:abstract ?a
                                          }
                                       }""")
                for row in qres:
                    s_label = row["l"]
                    s_uri = row["s"]
                    if "a" in row.labels:
                        if concatenate_label_abstract:
                            s_label = s_label + " " + row["a"]
                        else:
                            go.add((URIRef(s_uri), URIRef(u"http://dbpedia.org/ontology/abstract"),
                                    Literal(clean(row["a"]), lang=lang)))
                            gor.add((URIRef(s_uri), URIRef(u"http://dbpedia.org/ontology/abstract"),
                                    Literal(clean(row["a"]), lang=lang)))
                    go.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#has_step"), URIRef(s_uri)))
                    go.add((URIRef(s_uri), RDFS.label, Literal(clean(s_label), lang=lang)))
                    gor.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#has_step"), URIRef(s_uri)))
                    gor.add((URIRef(s_uri), RDFS.label, Literal(clean(s_label), lang=lang)))
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?s1
                                       WHERE {
                                         { <""" + str(main_uri) + """> prohow:has_method ?m .
                                          ?m prohow:has_step ?part .
                                          ?part prohow:has_method ?m1 .
                                          ?m1 prohow:has_step ?s .
                                          ?s prohow:requires ?s1 .
                                         }
                                         UNION
                                         {
                                          <""" + str(main_uri) + """> prohow:has_method ?m .
                                          ?m prohow:has_step ?part2 .
                                          ?part2 prohow:requires ?part1 .
                                          ?part1 prohow:has_method ?m1 .
                                          ?part2 prohow:has_method ?m2 .
                                          ?m2 prohow:has_step ?s .
                                          ?m1 prohow:has_step ?s1 .
                                          FILTER NOT EXISTS {
                                              ?s prohow:requires ?x .
                                            }
                                          FILTER NOT EXISTS {
                                              ?x prohow:requires ?s1 .
                                            }
                                         }
                                       }""")
                for row in qres:
                    s_uri = row["s"]
                    s_uri1 = row["s1"]
                    go.add((URIRef(s_uri), URIRef(u"http://w3id.org/prohow#requires"),URIRef(s_uri1)))
                    gor.add((URIRef(s_uri), URIRef(u"http://w3id.org/prohow#requires"), URIRef(s_uri1)))
            else:
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?l ?a
                                           WHERE {
                                              <""" + str(main_uri) + """> prohow:has_method ?m .
                                              ?m prohow:has_step ?s .
                                              ?s rdfs:label ?l
                                              OPTIONAL {
                                                ?s dbo:abstract ?a .
                                              }
                                           }""")
                for row in qres:
                    s_label = row["l"]
                    s_uri = row["s"]
                    if "a" in row.labels and not row["a"] is None:
                        if concatenate_label_abstract:
                            s_label = s_label + " " + row["a"]
                        else:
                            go.add((URIRef(s_uri), URIRef(u"http://dbpedia.org/ontology/abstract"),
                                    Literal(clean(row["a"]), lang=lang)))
                            gor.add((URIRef(s_uri), URIRef(u"http://dbpedia.org/ontology/abstract"),
                                    Literal(clean(row["a"]), lang=lang)))
                    go.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#has_step"), URIRef(s_uri)))
                    go.add((URIRef(s_uri), RDFS.label, Literal(clean(s_label), lang=lang)))
                    gor.add((URIRef(main_uri), URIRef(u"http://w3id.org/prohow#has_step"), URIRef(s_uri)))
                    gor.add((URIRef(s_uri), RDFS.label, Literal(clean(s_label), lang=lang)))
                qres = g.query(
                    sparql_prefixes + """SELECT DISTINCT ?s ?s1
                                   WHERE {
                                      <""" + str(main_uri) + """> prohow:has_method ?m .
                                      ?m prohow:has_step ?s .
                                      ?s prohow:requires ?s1
                                   }""")
                for row in qres:
                    s_uri = row["s"]
                    s_uri1 = row["s1"]
                    go.add((URIRef(s_uri), URIRef(u"http://w3id.org/prohow#requires"), URIRef(s_uri1)))
                    gor.add((URIRef(s_uri), URIRef(u"http://w3id.org/prohow#requires"), URIRef(s_uri1)))
            qres = g.query(
                sparql_prefixes + """SELECT DISTINCT ?o ?s
                                                   WHERE {
                                                      ?o owl:sameAs ?s
                                                   }""")
            for row in qres:
                go.add((URIRef(main_uri), URIRef(u"http://www.w3.org/2002/07/owl#sameAs"), URIRef(row["o"])))
                go.add((URIRef(main_uri), URIRef(u"http://www.w3.org/2002/07/owl#sameAs"), URIRef(row["s"])))
                gor.add((URIRef(main_uri), URIRef(u"http://www.w3.org/2002/07/owl#sameAs"), URIRef(row["o"])))
                gor.add((URIRef(main_uri), URIRef(u"http://www.w3.org/2002/07/owl#sameAs"), URIRef(row["s"])))
            out_simple.write(go.serialize(format='ttl', encoding='utf-8'))
        #print(" X graph has %s statements." % len(g))
    out.write(line+"\n\n")

    return True

def parse_file(file, lang):
    print "Parsing file "+str(file)
    f = open(file,'r')
    full_instruction = ""	
    found = False
    found_num = 0
    for line in f:
        if len(list_of_allowed_categories) == 0 and len(list_of_urls) == 0:
            found = True
        if 'oa:hasTarget <' in line:
            for url in list_of_urls:
                if "<"+str(url.lower())+">" in line.lower():
                    found = True
        if "rdf:type <" in line:
            line_parts = line.split("rdf:type <")
            type = line_parts[1][:-4]
            for allowed_concept in list_of_allowed_categories:
                if is_subclass_of(type,allowed_concept):
                    found = True
        if 'rdf:type prohow:instruction_set .' in line:
            # if the previous instruction set was selected, save it in output
            if found:
                if save(full_instruction,lang):
                  found_num += 1
            # start collecting a new instructions set
            found = False
            full_instruction = line
        else:
            if len(full_instruction) > 0:
                if "<" in line and ">" in line and ":" in line and "http:" in line:
                    line = string.replace(line, "(", "")#tring.replace(s, old, new[, maxreplace])
                    line = string.replace(line, ")", "")
                full_instruction = full_instruction+line
    if found:
        if save(full_instruction, lang):
          found_num += 1
    f.close()
    print "Found in file: "+str(found_num)
    return found_num


rootdir = os.getcwd()
total_found = 0
for subdir, dirs, files in os.walk(rootdir):
    for file in files:
        filepath = subdir + os.sep + file
        if filepath.endswith(".ttl"):
            if len(list_of_allowed_languages) > 0:
                for lang in list_of_allowed_languages:
                    if ntpath.basename(filepath).startswith(lang):
                        print filepath
                        total_found += parse_file(filepath, ntpath.basename(filepath)[0:2])
            else:
                total_found += parse_file(filepath, ntpath.basename(filepath)[0:2])
out.close()
if save_simplified:
    out_simple.close()
    out_simple_single = open("extracted_simplified_graph.rdf", "w")
    out_simple_single.write(gor.serialize(format='pretty-xml', encoding='utf-8'))
    out_simple_single.close()
print 'In total, '+str(total_found)+' were found'
